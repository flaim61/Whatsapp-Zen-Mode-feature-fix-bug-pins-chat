"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _plugin() {
  const data = require("@parcel/plugin");

  _plugin = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _jsonSourceMap() {
  const data = _interopRequireDefault(require("json-source-map"));

  _jsonSourceMap = function () {
    return data;
  };

  return data;
}

function _contentSecurityPolicyParser() {
  const data = _interopRequireDefault(require("content-security-policy-parser"));

  _contentSecurityPolicyParser = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _diagnostic() {
  const data = _interopRequireWildcard(require("@parcel/diagnostic"));

  _diagnostic = function () {
    return data;
  };

  return data;
}

function _schema() {
  const data = _interopRequireDefault(require("./schema"));

  _schema = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEP_LOCS = [['icons'], ['browser_action', 'default_icon'], ['browser_action', 'default_popup'], ['page_action', 'default_icon'], ['page_action', 'default_popup'], ['background', 'scripts'], ['chrome_url_overrides'], ['devtools_page'], ['options_ui', 'page'], ['sidebar_action', 'default_icon'], ['sidebar_action', 'default_panel'], ['storage', 'managed_schema'], ['theme', 'images', 'theme_frame'], ['theme', 'images', 'additional_backgrounds'], ['user_scripts', 'api_script']];

async function collectDependencies(asset, program, ptrs, hot) {
  var _program$browser_acti;

  // isEntry used whenever strictly necessary to preserve filename
  // also for globs because it's wasteful to write out every file name
  const fs = asset.fs;
  const filePath = asset.filePath;

  if (program.default_locale) {
    const locales = _path().default.join(_path().default.dirname(filePath), '_locales');

    let err = !(await fs.exists(locales)) ? 'key' : !(await fs.exists(_path().default.join(locales, program.default_locale))) ? 'value' : null;

    if (err) {
      throw new (_diagnostic().default)({
        diagnostic: [{
          message: 'Invalid Web Extension manifest',
          origin: '@parcel/transformer-webextension',
          filePath,
          codeFrame: {
            codeHighlights: [{ ...(0, _diagnostic().getJSONSourceLocation)(ptrs['/default_locale'], err),
              message: (0, _diagnostic().md)`Localization directory${err == 'value' ? ' for ' + program.default_locale : ''} does not exist: ${_path().default.relative(_path().default.dirname(filePath), _path().default.join(locales, program.default_locale))}`
            }]
          }
        }]
      });
    }

    for (const locale of await fs.readdir(locales)) {
      asset.addURLDependency(`_locales/${locale}/messages.json`, {
        isEntry: true,
        pipeline: 'url'
      });
    }
  }

  let needRuntimeBG = false;

  if (program.content_scripts) {
    for (let i = 0; i < program.content_scripts.length; ++i) {
      const sc = program.content_scripts[i];

      for (const k of ['css', 'js']) {
        const assets = sc[k] || [];

        for (let j = 0; j < assets.length; ++j) {
          assets[j] = asset.addURLDependency(assets[j], {
            isEntry: true,
            loc: {
              filePath,
              ...(0, _diagnostic().getJSONSourceLocation)(ptrs[`/content_scripts/${i}/${k}/${j}`], 'value')
            }
          });
        }
      }

      if (hot && sc.js && sc.js.length) {
        needRuntimeBG = true;
        sc.js.push(asset.addURLDependency('./runtime/autoreload.js', {
          resolveFrom: __filename
        }));
      }
    }
  }

  if (program.dictionaries) {
    for (const dict in program.dictionaries) {
      const sourceLoc = (0, _diagnostic().getJSONSourceLocation)(ptrs[`/dictionaries/${dict}`], 'value');
      const loc = {
        filePath,
        ...sourceLoc
      };
      const dictFile = program.dictionaries[dict];

      if (_path().default.extname(dictFile) != '.dic') {
        throw new (_diagnostic().default)({
          diagnostic: [{
            message: 'Invalid Web Extension manifest',
            origin: '@parcel/transformer-webextension',
            filePath,
            codeFrame: {
              codeHighlights: [{ ...sourceLoc,
                message: 'Dictionaries must be .dic files'
              }]
            }
          }]
        });
      }

      program.dictionaries[dict] = asset.addURLDependency(dictFile, {
        isEntry: true,
        loc
      });
      asset.addURLDependency(dictFile.slice(0, -4) + '.aff', {
        isEntry: true,
        loc
      });
    }
  }

  if ((_program$browser_acti = program.browser_action) !== null && _program$browser_acti !== void 0 && _program$browser_acti.theme_icons) {
    for (let i = 0; i < program.browser_action.theme_icons.length; ++i) {
      const themeIcon = program.browser_action.theme_icons[i];

      for (const k of ['light', 'dark']) {
        const loc = (0, _diagnostic().getJSONSourceLocation)(ptrs[`/browser_action/theme_icons/${i}/${k}`], 'value');
        themeIcon[k] = asset.addURLDependency(themeIcon[k], {
          isEntry: true,
          loc: { ...loc,
            filePath
          }
        });
      }
    }
  }

  if (program.web_accessible_resources) {
    let war = [];

    for (let i = 0; i < program.web_accessible_resources.length; ++i) {
      // TODO: this doesn't support Parcel resolution
      const globFiles = (await (0, _utils().glob)(_path().default.join(_path().default.dirname(filePath), program.web_accessible_resources[i]), fs, {})).map(fp => asset.addURLDependency(_path().default.relative(_path().default.dirname(filePath), fp), {
        isEntry: true,
        loc: {
          filePath,
          ...(0, _diagnostic().getJSONSourceLocation)(ptrs[`/web_accessible_resources/${i}`])
        }
      }));
      war = war.concat(globFiles);
    }

    program.web_accessible_resources = war;
  }

  for (const loc of DEP_LOCS) {
    const location = '/' + loc.join('/');
    if (!ptrs[location]) continue;
    let parent = program;

    for (let i = 0; i < loc.length - 1; ++i) {
      parent = parent[loc[i]];
    }

    const lastLoc = loc[loc.length - 1];
    const obj = parent[lastLoc];
    if (typeof obj == 'string') parent[lastLoc] = asset.addURLDependency(obj, {
      isEntry: true,
      loc: {
        filePath,
        ...(0, _diagnostic().getJSONSourceLocation)(ptrs[location], 'value')
      },
      pipeline: _path().default.extname(obj) == '.json' ? 'url' : undefined
    });else {
      for (const k of Object.keys(obj)) {
        obj[k] = asset.addURLDependency(obj[k], {
          isEntry: true,
          loc: {
            filePath,
            ...(0, _diagnostic().getJSONSourceLocation)(ptrs[location + '/' + k], 'value')
          },
          pipeline: _path().default.extname(obj[k]) == '.json' ? 'url' : undefined
        });
      }
    }
  }

  if (needRuntimeBG) {
    if (!program.background) {
      program.background = {};
    }

    if (!program.background.scripts) {
      program.background.scripts = [];
    }

    program.background.scripts.push(asset.addURLDependency('./runtime/autoreload-bg.js', {
      resolveFrom: __filename
    }));
  }
}

function cspPatchHMR(policy) {
  if (policy) {
    const csp = (0, _contentSecurityPolicyParser().default)(policy);
    policy = '';

    if (!csp['script-src']) {
      csp['script-src'] = ["'self' 'unsafe-eval' blob: filesystem:"];
    }

    if (!csp['script-src'].includes("'unsafe-eval'")) {
      csp['script-src'].push("'unsafe-eval'");
    }

    for (const k in csp) {
      policy += `${k} ${csp[k].join(' ')};`;
    }

    return policy;
  } else {
    return "script-src 'self' 'unsafe-eval' blob: filesystem:;" + "object-src 'self' blob: filesystem:;";
  }
}

var _default = new (_plugin().Transformer)({
  async transform({
    asset,
    options
  }) {
    const code = await asset.getCode();

    const parsed = _jsonSourceMap().default.parse(code);

    const data = parsed.data;

    _utils().validateSchema.diagnostic(_schema().default, {
      data: data,
      source: code,
      filePath: asset.filePath
    }, '@parcel/transformer-webextension', 'Invalid Web Extension manifest');

    await collectDependencies(asset, data, parsed.pointers, Boolean(options.hmrOptions));

    if (options.hmrOptions) {
      // To enable HMR, we must override the CSP to allow 'unsafe-eval'
      data.content_security_policy = cspPatchHMR(data.content_security_policy);
    }

    asset.meta.handled = true;
    asset.setCode(JSON.stringify(data, null, 2));
    return [asset];
  }

});

exports.default = _default;